package main

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"strconv"
	"strings"
	"testing"

	"golang.org/x/text/transform"
)

func TestIsBlock(t *testing.T) {
	cases := []struct {
		input  string
		result bool
	}{
		{input: "grep", result: false},
		{input: "grep aaa", result: false},
		{input: "grepa aaa", result: true},
	}
	for _, tc := range cases {
		result := isBlock(tc.input)
		if result != tc.result {
			t.Errorf("result: %s, expected: %s", strconv.FormatBool(result), strconv.FormatBool(tc.result))
		}
	}
}

func TestSpinner(t *testing.T) {
	cases := []string{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"}
	s := spinner()
	for _, tc := range cases {
		result := s()
		if result != tc {
			t.Errorf("result: %s, expected: %s", result, tc)
		}
	}
}

func TestSetPrompt(t *testing.T) {
	cases := []struct {
		input  string
		prompt string
		text   string
	}{
		{input: "ls", prompt: "", text: "ls"},
		{input: "ls | grep a", prompt: "ls ", text: " grep a"},
		{input: "ls | grep a | wc", prompt: "ls | grep a ", text: " wc"},
	}
	for _, tc := range cases {
		c := newCliPane()
		c.setPrompt(tc.input)
		if c.prompt != tc.prompt {
			r := strings.Replace(fmt.Sprintf(`result:   "%s"`, c.prompt), "\n", "\\n", -1)
			e := strings.Replace(fmt.Sprintf(`expected: "%s"`, tc.prompt), "\n", "\\n", -1)
			t.Errorf("\n%s\n%s", r, e)
		}
		if c.GetText() != tc.text {
			r := strings.Replace(fmt.Sprintf(`result:   "%s"`, c.GetText()), "\n", "\\n", -1)
			e := strings.Replace(fmt.Sprintf(`expected: "%s"`, tc.text), "\n", "\\n", -1)
			t.Errorf("\n%s\n%s", r, e)
		}
	}
}

func TestAddPrompt(t *testing.T) {
	cases := []struct {
		prompt string
		text   string
		result string
	}{
		{prompt: "", text: "ls ", result: "ls "},
		{prompt: "ls |", text: " grep a", result: "ls | grep a"},
	}
	for _, tc := range cases {
		c := newCliPane()
		c.setPrompt(tc.prompt)
		c.SetText(tc.text)
		c.addPrompt()
		if c.prompt != tc.result {
			r := strings.Replace(fmt.Sprintf(`result:   "%s"`, c.prompt), "\n", "\\n", -1)
			e := strings.Replace(fmt.Sprintf(`expected: "%s"`, tc.result), "\n", "\\n", -1)
			t.Errorf("\n%s\n%s", r, e)
		}
	}
}

func TestSetData(t *testing.T) {
	getTerminalHeight = func() int {
		return 6
	}

	cases := []struct {
		input   string
		result  string
		result2 string
	}{
		{input: "a\n", result: "a\n", result2: "a\n"},
		{input: "a\na\na\na\na", result: "a\na\na\na\na", result2: "a\na\na"},
	}
	for _, tc := range cases {
		si := newStdinViewPane()
		si.setData([]byte(tc.input))
		if !bytes.Equal(si.data, []byte(tc.result)) {
			r := strings.Replace(fmt.Sprintf(`result:   "%s"`, string(si.data)), "\n", "\\n", -1)
			e := strings.Replace(fmt.Sprintf(`expected: "%s"`, tc.result), "\n", "\\n", -1)
			t.Errorf("\n%s\n%s", r, e)
		}
		if si.GetText(true) != tc.result2 {
			r := strings.Replace(fmt.Sprintf(`result:   "%s"`, si.GetText(true)), "\n", "\\n", -1)
			e := strings.Replace(fmt.Sprintf(`expected: "%s"`, tc.result2), "\n", "\\n", -1)
			t.Errorf("\n%s\n%s", r, e)
		}
	}
}

func TestExecCommandStdin(t *testing.T) {
	shell = "sh"
	getTerminalHeight = func() int {
		return 6
	}

	cases := []struct {
		cmd     string
		stdin   string
		result  string
		result2 string
	}{
		{cmd: "echo a", stdin: "", result: "a\n", result2: "a\n"},
		{cmd: "grep a", stdin: "a\nb\na\na\n", result: "a\na\na\n", result2: "a\na\na"},
	}
	for _, tc := range cases {
		si := newStdinViewPane()
		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()
		si.execCommand(ctx, tc.cmd, []byte(tc.stdin))
		if !bytes.Equal(si.data, []byte(tc.result)) {
			r := strings.Replace(fmt.Sprintf(`result:   "%s"`, string(si.data)), "\n", "\\n", -1)
			e := strings.Replace(fmt.Sprintf(`expected: "%s"`, tc.result), "\n", "\\n", -1)
			t.Errorf("\n%s\n%s", r, e)
		}
		if si.GetText(true) != tc.result2 {
			r := strings.Replace(fmt.Sprintf(`result:   "%s"`, si.GetText(true)), "\n", "\\n", -1)
			e := strings.Replace(fmt.Sprintf(`expected: "%s"`, tc.result2), "\n", "\\n", -1)
			t.Errorf("\n%s\n%s", r, e)
		}
	}
}

func TestExecCommandStdout(t *testing.T) {
	shell = "sh"
	getTerminalHeight = func() int {
		return 6
	}

	cases := []struct {
		cmd    string
		stdin  string
		result string
	}{
		{cmd: "echo a", stdin: "", result: "a\n"},
		{cmd: "echo a 1>&2", stdin: "", result: "a\n"},
		{cmd: "grep a", stdin: "a\nb\na\na\n", result: "a\na\na"},
	}
	for _, tc := range cases {
		so := newStdoutViewPane()
		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()
		so.execCommand(ctx, tc.cmd, []byte(tc.stdin))
		if so.GetText(true) != tc.result {
			r := strings.Replace(fmt.Sprintf(`result:   "%s"`, so.GetText(true)), "\n", "\\n", -1)
			e := strings.Replace(fmt.Sprintf(`expected: "%s"`, tc.result), "\n", "\\n", -1)
			t.Errorf("\n%s\n%s", r, e)
		}
	}
}

func TestTransform(t *testing.T) {
	cases := []struct {
		line   int
		limit  int
		input  string
		result string
	}{
		{
			line:   0,
			limit:  3,
			input:  "foo\n",
			result: "foo\n",
		},
		{
			line:   0,
			limit:  2,
			input:  "foo\nbar\n",
			result: "foo\nbar",
		},
		{
			line:   0,
			limit:  1,
			input:  "foo\nbar\n",
			result: "foo",
		},
		{
			line:   0,
			limit:  3,
			input:  strings.Repeat("a", 4096) + "foo\n",
			result: strings.Repeat("a", 4096) + "foo\n",
		},
		{
			line:   0,
			limit:  2,
			input:  strings.Repeat("a", 4096) + "foo\nbar\n",
			result: strings.Repeat("a", 4096) + "foo\nbar",
		},
		{
			line:   0,
			limit:  1,
			input:  strings.Repeat("a", 4096) + "foo\nbar\n",
			result: strings.Repeat("a", 4096) + "foo",
		},
		{
			line:   5,
			limit:  5,
			input:  "foo\n",
			result: "",
		},
	}
	for _, tc := range cases {
		stdin := bytes.NewBufferString(tc.input)
		stdout := new(bytes.Buffer)

		tt := &textLineTransformer{
			line:  tc.line,
			limit: tc.limit,
			temp:  []byte(""),
		}
		w := transform.NewWriter(stdout, tt)
		io.Copy(w, stdin)

		if stdout.String() != tc.result {
			r := strings.Replace(fmt.Sprintf(`result:   "%s"`, stdout.String()), "\n", "\\n", -1)
			e := strings.Replace(fmt.Sprintf(`expected: "%s"`, tc.result), "\n", "\\n", -1)
			t.Errorf("\n%s\n%s", r, e)
		}
	}
}
